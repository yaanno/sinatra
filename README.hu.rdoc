= Sinatra

A Sinatra egy DSL webalkalmazások Ruby nyelven történő fejlesztéséhez, minimális
energiabefektetéssel:

  # myapp.rb
  require 'rubygems'
  require 'sinatra'
  get '/' do
    'Helló Világ!'
  end

Telepítsd a gem-et és indítsd el az alkalmazást a következőképpen:

  sudo gem install sinatra
  ruby myapp.rb

Az alkalmazás elérhető lesz itt: http://localhost:4567

== Útvonalak (routes)

A Sinatrában az útvonalat egy HTTP metódus és egy URL-re illeszkedő minta
párosa alkotja. Minden egyes útvonalhoz tartozik egy blokk:

  get '/' do
    .. megjelenítünk valamit ..
  end

  post '/' do
    .. létrehozunk valamit ..
  end

  put '/' do
    .. frissítünk valamit ..
  end

  delete '/' do
    .. törlünk valamit ..
  end

Az útvonalak illeszkedését a rendszer a definiálásuk sorrendjében
ellenőrzi. Sorrendben mindig az első illeszkedő útvonalhoz tartozó metódus kerül
meghívásra.

Az útvonalminták tartalmazhatnak paramétereket is, melyeket a <tt>params</tt>
hash-ből érhetünk el:

  get '/hello/:name' do
    # illeszkedik a "GET /hello/foo" és a "GET /hello/bar" útvonalakra
    # ekkor params[:name] értéke 'foo' vagy 'bar' lesz
    "Helló #{params[:name]}!"
  end

A kulcsszavas argumentumokat (named parameters) blokk paraméterek útján
is el tudod érni:

  get '/hello/:name' do |n|
    "Helló #{n}!"
  end

Az útvonalminták közt szerepelhetnek joker paraméterek is, melyeket a 
<tt>params[:splat]</tt> tömbön keresztül tudunk elérni.

  get '/say/*/to/*' do
    # illeszkedik a /say/hello/to/world mintára
    params[:splat] # => ["hello", "world"]
  end

  get '/download/*.*' do
    # illeszkedik a /download/path/to/file.xml mintára
    params[:splat] # => ["path/to/file", "xml"]
  end

Reguláris kifejezések is alkalmazhatók útvonalmintákként:

  get %r{/hello/([\w]+)} do
    "Helló, #{params[:captures].first}!"
  end

Esetleg blokk paraméterek:

  get %r{/hello/([\w]+)} do |c|
    "Helló, #{c}!"
  end

Az útvonalak azonban számos egyéb illeszkedési feltétel szerint is
tervezhetők, így például az user agent karakterláncot alapul véve:

  get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
    "A Songbird #{params[:agent][0]} verzióját használod"
  end

  get '/foo' do
    # illeszkedik az egyéb user agentekre
  end

== Statikus állományok

A statikus fájlok kiszolgálása a <tt>./public</tt> könyvtárból
történik, de természetesen más könyvtárat is megadhatsz erre a célra,
mégpedig a <tt>:public</tt> kapcsoló beállításával:

  set :public, File.dirname(__FILE__) + '/static'

Fontos mgejegyezni, hogy a nyilvános könyvtár neve nem szerepel az URL-ben.
A <tt>./public/css/style.css</tt> fájl az
<tt>http://example.com/css/style.css</tt> URL-en lesz elérhető.

== Nézetek és Sablonok

A sablonfájlokat rendszerint a  <tt>./views</tt> könyvtárba helyezzük, de
itt is lehetőség nyílik egyéb könyvtár használatára:

  set :views, File.dirname(__FILE__) + '/templates'

Nagyon fontos észben tartani, hogy a sablononkra mindig szimbólumokkal
hivatkozunk, még akkor is, ha egyéb (ebben az esetben a 
<tt>:'subdir/template'</tt>) könyvtárban tároljuk őket. A renderelő
metódusok minden, nekik közvetlenül átadott karakterláncot megjelenítenek.

=== Haml sablonok

HAML sablonok rendereléséhez szükségünk lesz a haml gem-re vagy könyvtárra:

  ## Importáljuk be a haml-t az alkalmazásba
  require 'haml'

  get '/' do
    haml :index
  end

Ez szépen lerendereli a <tt>./views/index.haml</tt> sablont.

A {Haml kapcsolói}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Haml.html]
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
{Options and Configurations}[http://www.sinatrarb.com/configuration.html] lapot.
A globális beállításokat lehetőségünk van felülírni metódus szinten is.

  set :haml, {:format => :html5 } # az alapértelmezett Haml formátum az :xhtml

  get '/' do
    haml :index, :haml_options => {:format => :html4 } # immár felülírva
  end


=== Erb sablonok

  ## Importáljuk be az erb-t az alkalmazásba
  require 'erb'

  get '/' do
    erb :index
  end

Ez a <tt>./views/index.erb</tt> sablont fogja lerenderelni.

=== Builder sablonok

Szükségünk lesz a builder gem-re vagy könyvtárra a builder sablonok
rendereléséhez:

  ## Importáljuk be a builder-t az alkalmazásba
  require 'builder'

  get '/' do
    content_type 'application/xml', :charset => 'utf-8'
    builder :index
  end

Ez pedig a <tt>./views/index.builder</tt> állományt fogja renderelni.

=== Sass sablonok

Sass sablonok használatához szükség lesz a sass gem-re vagy könyvtárra:

  ## Be kell importálni a haml, vagy a sass könyvtárat
  require 'sass'

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet
  end

Így a <tt>./views/stylesheet.sass</tt> fájl máris renderelhető.

A {Sass kapcsolói}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Sass.html]
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
{Options and Configurations}[http://www.sinatrarb.com/configuration.html] lapot.
A globális beállításokat lehetőségünk van felülírni metódus szinten is.

  set :sass, {:style => :compact } # az alapértelmezett Sass stílus a :nested

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet, :sass_options => {:style => :expanded } # felülírva
  end


=== Beágyazott sablonok

  get '/' do
    haml '%div.title Helló Világ'
  end

Lerendereli a beágyazott sablon karakerláncát.

=== Változók elérése a sablonokban

A sablonok ugyanabban a kontextusban kerülnek kiértékelésre, mint az
útvonal metódusok (route handlers). Az útvonal metódusokban megadott
változók közvetlenül elérhetőek lesznek a sablonokban:

  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.name'
  end

De megadhatod egy lokális változókat tartalmazó explicit hash-ben is:

  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.name', :locals => { :foo => foo }
  end

Ezt leginkább akkor érdemes megtenni, ha partial-eket akarunk renderelni
valamely más sablonból.

=== Fájlon belüli sablonok

Sablonokat úgy is megadhatunk, hogy egyszerűen az alkalmazás fájl
végére begépeljük őket:

  require 'rubygems'
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Helló Világ!!!!!

Megjegyzés: azok a fájlon belüli sablonok, amelyek az alkalmazás fájl végére
kerülnek és függnek a sinatra könyvtártól, automatikusan betöltődnek.
Ha ugyanezt más alkalmazásfájlban is szeretnéd megtenni, hívd meg 
a <tt>use_in_file_templates!</tt> metódust az adott fájlban.

=== Kulcsszavas sablonok

Sablonokat végül a felsőszintű <tt>template</tt> metódussal is 
definiálhatunk: 

  template :layout do
    "%html\n  =yield\n"
  end

  template :index do
    '%div.title Helló Világ!'
  end

  get '/' do
    haml :index
  end

Ha létezik "layout" nevű sablon, akkor az minden esetben meghívódik, amikor
csak egy sablon renderelésre kerül. A layoutokat ki lehet kapcsolni a
<tt>:layout => false</tt> meghívásával.

  get '/' do
    haml :index, :layout => !request.xhr?
  end

== Helperek

Használd a felső szintű <tt>helpers</tt> metódust azokhoz a helper
függvényekhez, amiket az útvonal metódusokban és a sablonokban akarsz
használni:

  helpers do
    def bar(name)
      "#{name}bar"
    end
  end

  get '/:name' do
    bar(params[:name])
  end

== Szűrők (filters)

Az előszűrők (before filter) az adott hívás kontextusában minden egyes
kérés alkalmával kiértékelődnek, így módosíthatják a kérést és a
választ egyaránt. A szűrőkbe felvett példányváltozók elérhetőek lesznek
az útvonalakban és a sablonokban is:

  before do
    @note = 'Csá!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=> 'Szeva!'
    params[:splat] #=> 'bar/baz'
  end

== Megállítás

Egy kérés előszűrőben vagy útvonalban történő azonnal blokkolásához
használd a következő parancsot:

  halt

A megállításkor egy blokktörzset is megadhatsz ...

  halt 'ez fog megjelenni a törzsben'

Vagy állítsd be a HTTP státuszt és a törzset is egyszerre ...

  halt 401, 'menj innen!'

== Passzolás

Az útvonalak továbbadhatják a végrehajtást egy másik útvonalnak 
a <tt>pass</tt> függvényhívással:

  get '/guess/:who' do
    pass unless params[:who] == 'Frici'
    "Elkaptál!"
  end

  get '/guess/*' do
    "Elhibáztál!"
  end

Az útvonal blokkja azonnal kilép és átadja a vezérlést a következő
illeszkedő útvonalnak. Ha nem talál megfelelő útvonalat, a Sinatra
egy 404-es hibával tér vissza.

== Beállítások

Csak indításkor, de minden környezetre érvényesen fusson le:

  configure do
    ...
  end

Csak akkor fusson le, ha a környezet (a RACK_ENV környezeti változóban)
<tt>:production</tt>-ra van állítva:

  configure :production do
    ...
  end

Csak akkor fusson le, ha a környezet <tt>:production</tt> vagy <tt>:test</tt>:

  configure :production, :test do
    ...
  end

== Hibakezelés

A hibakezelők ugyanabban a kontextusban futnak le, mint az útvonalak és
előszűrők, ezért számukra is elérhetőek mindazok a könyvtárak, amelyek
az utóbbiak rendelkezésére is állnak; így például a <tt>haml</tt>, 
az <tt>erb</tt>, a <tt>halt</tt> stb.

=== Nem található

Amikor a <tt>Sinatra::NotFound</tt> kivétel fellép, vagy a válasz HTTP
státuszkódja 404-es, mindig a <tt>not_found</tt> metódus hívódik meg.

  not_found do
    'Sehol sem találom, amit keresel'
  end

=== Hiba

Az +error+ metódus hívódik meg olyankor, amikor egy útvonal, blokk vagy
előszűrő kivételt vált ki. A kivétel objektum lehívható a
<tt>sinatra.error</tt> Rack változótól:

  error do
    'Elnézést, de valami szörnyű hiba lépett fel - ' + env['sinatra.error'].name
  end

Egyéni hibakezelés:

  error MyCustomError do
    'Szóval az van, hogy...' + request.env['sinatra.error'].message
  end

És amikor fellép:

  get '/' do
    raise MyCustomError, 'megmakkant a cucmány!'
  end

Ez fog megjelenni:

  Szóval az van, hogy... megmakkant a cucmány!

Sinatra installs special <tt>not_found</tt> and <tt>error</tt> handlers when
running under the development environment.

== Mime típusok

A <tt>send_file</tt> metódus használatakor, vagy statikus fájlok
kiszolgálásakor előfordulhat, hogy a Sinatra nem ismeri fel a fájlok
mime típusát. Ilyenkor használd a +mime+ kapcsolót a fájlkiterjesztés
bevezetéséhez:

  mime :foo, 'text/foo'

== Rack Middleware

Sinatra rides on Rack[http://rack.rubyforge.org/], a minimal standard
interface for Ruby web frameworks. One of Rack's most interesting capabilities
for application developers is support for "middleware" -- components that sit
between the server and your application monitoring and/or manipulating the
HTTP request/response to provide various types of common functionality.

Sinatra makes building Rack middleware pipelines a cinch via a top-level
+use+ method:

  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/hello' do
    'Hello World'
  end

The semantics of +use+ are identical to those defined for the
Rack::Builder[http://rack.rubyforge.org/doc/classes/Rack/Builder.html] DSL
(most frequently used from rackup files). For example, the +use+ method
accepts multiple/variable args as well as blocks:

  use Rack::Auth::Basic do |username, password|
    username == 'admin' && password == 'secret'
  end

Rack is distributed with a variety of standard middleware for logging,
debugging, URL routing, authentication, and session handling. Sinatra uses
many of of these components automatically based on configuration so you
typically don't have to +use+ them explicitly.

== Testing

Sinatra tests can be written using any Rack-based testing library
or framework. {Rack::Test}[http://gitrdoc.com/brynary/rack-test] is
recommended:

  require 'my_sinatra_app'
  require 'rack/test'

  class MyAppTest < Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Hello World!', last_response.body
    end

    def test_with_params
      get '/meet', :name => 'Frank'
      assert_equal 'Hello Frank!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
      assert_equal "You're using Songbird!", last_response.body
    end
  end

NOTE: The built-in Sinatra::Test module and Sinatra::TestHarness class
are deprecated as of the 0.9.2 release.

== Sinatra::Base - Middleware, Libraries, and Modular Apps

Defining your app at the top-level works well for micro-apps but has
considerable drawbacks when building reuseable components such as Rack
middleware, Rails metal, simple libraries with a server component, or
even Sinatra extensions. The top-level DSL pollutes the Object namespace
and assumes a micro-app style configuration (e.g., a single application
file, ./public and ./views directories, logging, exception detail page,
etc.). That's where Sinatra::Base comes into play:

  require 'sinatra/base'

  class MyApp < Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Hello world!'
    end
  end

The MyApp class is an independent Rack component that can act as
Rack middleware, a Rack application, or Rails metal. You can +use+ or
+run+ this class from a rackup +config.ru+ file; or, control a server
component shipped as a library:

   MyApp.run! :host => 'localhost', :port => 9090

The methods available to Sinatra::Base subclasses are exactly as those
available via the top-level DSL. Most top-level apps can be converted to
Sinatra::Base components with two modifications:

* Your file should require +sinatra/base+  instead of +sinatra+;
  otherwise, all of Sinatra's DSL methods are imported into the main
  namespace.
* Put your app's routes, error handlers, filters, and options in a subclass
  of Sinatra::Base.

+Sinatra::Base+ is a blank slate. Most options are disabled by default,
including the built-in server. See {Options and Configuration}[http://sinatra.github.com/configuration.html]
for details on available options and their behavior.

SIDEBAR: Sinatra's top-level DSL is implemented using a simple delegation
system. The +Sinatra::Application+ class -- a special subclass of
Sinatra::Base -- receives all :get, :put, :post, :delete, :before,
:error, :not_found, :configure, and :set messages sent to the
top-level. Have a look at the code for yourself: here's the
{Sinatra::Delegator mixin}[http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064]
being {included into the main namespace}[http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb#L25].

== Parancssor

Sinatra alkalmazásokat közvetlenül futtathatunk:

  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-s HANDLER]

Az alábbi kapcsolókat ismeri fel a rendszer:

  -h # segítség
  -p # a port beállítása (alapértelmezés szerint ez a 4567-es)
  -e # a környezet beállítása (alapértelmezés szerint ez a development)
  -s # a rack szerver/handler beállítása (alapértelmezetten ez a thin)
  -x # a mutex lock bekapcsolása (alapértelmezetten ki van kapcsolva)

== Fejlesztői változat

Ha a Sinatra legfrissebb, fejlesztői változatát szeretnéd használni,
készíts egy helyi másolatot és indítsd az alkalmazásodat úgy,
hogy a <tt>sinatra/lib</tt> könyvtár elérhető legyen a 
<tt>LOAD_PATH</tt>-on:

  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb

De hozzá is adhatod a <tt>sinatra/lib</tt> könyvtárat a <tt>LOAD_PATH</tt>-hoz
az alkalmazásodban:

  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/about' do
    "A következő változatot futtatom " + Sinatra::VERSION
  end

A Sinatra frissítését később így végezheted el:

  cd myproject/sinatra
  git pull

== További információk

* {A projekt weboldala}[http://sinatra.github.com/] - Kiegészítő dokumentáció,
  hírek, hasznos linkek
* {Közreműködés}[http://sinatra.github.com/contributing.html] - Hibát találtál?
  Segítségre van szükséged? Foltot küldenél be?
* {Lighthouse}[http://sinatra.lighthouseapp.com] - Hibakövetés és kiadások
* {Twitter}[http://twitter.com/sinatra]
* {Levelezőlista}[http://groups.google.com/group/sinatrarb]
* {IRC: #sinatra}[irc://chat.freenode.net/#sinatra] a http://freenode.net-en
