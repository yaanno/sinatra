= Sinatra

A Sinatra egy DSL webalkalmazások Ruby nyelven történő fejlesztéséhez, minimális
energiabefektetéssel:

  # myapp.rb
  require 'rubygems'
  require 'sinatra'
  get '/' do
    'Helló Világ!'
  end

Telepítsd a gem-et és indítsd el az alkalmazást a következőképpen:

  sudo gem install sinatra
  ruby myapp.rb

Az alkalmazás elérhető lesz itt: http://localhost:4567

== Útvonalak (routes)

A Sinatrában az útvonalat egy HTTP metódus és egy URL-re illeszkedő minta
párosa alkotja. Minden egyes útvonalhoz tartozik egy blokk:

  get '/' do
    .. megjelenítünk valamit ..
  end

  post '/' do
    .. létrehozunk valamit ..
  end

  put '/' do
    .. frissítünk valamit ..
  end

  delete '/' do
    .. törlünk valamit ..
  end

Az útvonalak illeszkedését a rendszer a definiálásuk sorrendjében
ellenőrzi. Sorrendben mindig az első illeszkedő útvonalhoz tartozó metódus kerül
meghívásra.

Az útvonalminták tartalmazhatnak paramétereket is, melyeket a <tt>params</tt>
hash-ből érhetünk el:

  get '/hello/:name' do
    # illeszkedik a "GET /hello/foo" és a "GET /hello/bar" útvonalakra
    # ekkor params[:name] értéke 'foo' vagy 'bar' lesz
    "Helló #{params[:name]}!"
  end

De nevesített blokk paraméterek útján is el tudod érni:
# FIXME You can also access named parameters via block parameters:

  get '/hello/:name' do |n|
    "Helló #{n}!"
  end

Az útvonalminták közt szerepelhetnek joker paraméterek is, melyeket a 
<tt>params[:splat]</tt> tömbön keresztül tudunk elérni.
# FIXME Route patterns may also include splat (or wildcard) parameters, accessible
# via the <tt>params[:splat]</tt> array.

  get '/say/*/to/*' do
    # illeszkedik a /say/hello/to/world mintára
    params[:splat] # => ["hello", "world"]
  end

  get '/download/*.*' do
    # illeszkedik a /download/path/to/file.xml mintára
    params[:splat] # => ["path/to/file", "xml"]
  end

Reguláris kifejezések is alkalmazhatók útvonalak illesztéséhez:

  get %r{/hello/([\w]+)} do
    "Helló, #{params[:captures].first}!"
  end

Vagy blokk paraméterek:

  get %r{/hello/([\w]+)} do |c|
    "Helló, #{c}!"
  end

Az útvonalak azonban számtalan egyéb illeszkedési feltétel szerint is
tervezhetők, így például az user agent karakterláncra építve:

  get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
    "A Songbird #{params[:agent][0]} verzióját használod"
  end

  get '/foo' do
    # illeszkedik az egyéb user agentekre
  end

== Statikus állományok

A statikus fájlok kiszolgálása a <tt>./public</tt> könyvtárból
történik, de természetesen más könyvtárat is megadhatsz erre a célra,
mégpedig a <tt>:public</tt> opció beállításával:

  set :public, File.dirname(__FILE__) + '/static'

Fontos mgejegyezni, hogy a nyilvános könyvtár neve nem szerepel az URL-ben.
A <tt>./public/css/style.css</tt> fájl az
<tt>http://example.com/css/style.css</tt> URL-en érhető el.

== Nézetek és Sablonok

A sablonfájlokat rendszerint a  <tt>./views</tt> könyvtárba helyezzük, de
itt is lehetőség nyílik egyéb könyvtár használatára:

  set :views, File.dirname(__FILE__) + '/templates'

Nagyon fontos észben tartani, hogy a sablononkra mindig szimbólumokkal
hivatkozunk, még akkor is, ha egyéb (ebben az esetben a 
<tt>:'subdir/template'</tt>) könyvtárban tároljuk őket. 
# FIXME Rendering methods will render any strings passed to them directly.

=== Haml sablonok

HAML sablonok rendereléséhez szükségünk lesz a haml gem-re/könyvtárra:

  ## Importáljuk be a haml-t az alkalmazásba
  require 'haml'

  get '/' do
    haml :index
  end

Ez szépen lerendereli a <tt>./views/index.haml</tt> sablont.

A {Haml beállításai}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Haml.html]
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
{Options and Configurations}[http://www.sinatrarb.com/configuration.html] lapot,
ám ezek is felülírhatók akár metódusszinten.

  set :haml, {:format => :html5 } # az alapértelmezett Haml formátum az :xhtml

  get '/' do
    haml :index, :haml_options => {:format => :html4 } # immár felülírva
  end


=== Erb sablonok

  ## Importáljuk be az erb-t az alkalmazásba
  require 'erb'

  get '/' do
    erb :index
  end

Ez a <tt>./views/index.erb</tt> sablont fogja lerenderelni.

=== Builder sablonok

Szükségünk lesz a builder gem-re vagy könyvtárra a builder sablonok
rendereléséhez:

  ## Importáljuk be a builder-t az alkalmazásba
  require 'builder'

  get '/' do
    content_type 'application/xml', :charset => 'utf-8'
    builder :index
  end

Ez pedig a <tt>./views/index.builder</tt> állományt fogja renderelni.

=== Sass sablonok

Sass sablonok használatához szükség lesz a sass gem-re vagy könyvtárra:

  ## Be kell importálni a haml, vagy a sass könyvtárat
  require 'sass'

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet
  end

Így a <tt>./views/stylesheet.sass</tt> fájl máris renderelhető.

A {Sass beállításai}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Sass.html]
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
{Options and Configurations}[http://www.sinatrarb.com/configuration.html] lapot,
ám ezek is felülírhatók akár metódusszinten.

  set :sass, {:style => :compact } # az alapértelmezett Sass stílus a :nested

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet, :sass_options => {:style => :expanded } # felülírva
  end


=== Beágyazott sablonok

  get '/' do
    haml '%div.title Helló Világ'
  end

Lerendereli a beágyazott sablon karakerláncát.

=== Változók elérése a sablonokban

A sablonok ugyanabban a kontextusban kerülnek kiértékelésre, mint az
útvonal metódusok (route handlers). Az útvonal metódusokban megadott
változók közvetlenül elérhetőek lesznek a sablonokban:

  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.name'
  end

De megadhatod egy lokális változókat tartalmazó explicit hash-ben is:

  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.name', :locals => { :foo => foo }
  end

Ezt leginkább akkor érdemes megtenni, ha partial-eket akarunk renderelni
valamely más sablonból.

=== In-file sablonok

Sablonokat úgy is megadhatunk, hogy egyszerűen az alkalmazás fájl
végére begépeljük:

  require 'rubygems'
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Helló Világ!!!!!

Megjegyzés: azok az in-file sablonok, amelyek az alkalmazás fájl végére
kerülnek és függnek a sinatra könyvtártól, automatikusan betöltődnek.
Ha ugyanezt más alkalmazásfájlban is szeretnéd megtenni, hívd meg 
a <tt>use_in_file_templates!</tt> metódust az adott fájlban.

=== Elnevezett sablonok

Sablonokat végül a felsőszintű <tt>template</tt> metódussal is 
definiálhatunk: 

  template :layout do
    "%html\n  =yield\n"
  end

  template :index do
    '%div.title Helló Világ!'
  end

  get '/' do
    haml :index
  end

Ha létezik "layout" nevű sablon, akkor az minden esetben meghívódik, amikor
csak egy sablon renderelésre kerül. A layoutokat ki lehet kapcsolni a
<tt>:layout => false</tt> meghívásával.

  get '/' do
    haml :index, :layout => !request.xhr?
  end

== Helperek

Használd a felső szintű <tt>helpers</tt> metódust azokhoz a helper
függvényekhez, amiket az útvonal metódusokban és a sablonokban akarsz
használni:

  helpers do
    def bar(name)
      "#{name}bar"
    end
  end

  get '/:name' do
    bar(params[:name])
  end

== Szűrők (filter)

Az előszűrők (before filter) az adott hívás kontextusában minden egyes
kérés alkalmával kiértékelődnek, így módosíthatják a kérést és a
választ. A szűrőkbe felvett példányváltozók elérhetőek lesznek az
útvonalakban és a sablonokban:

  before do
    @note = 'Csá!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=> 'Szeva!'
    params[:splat] #=> 'bar/baz'
  end

== Megállítás

Egy kérés előszűrőben vagy útvonalban történő azonnal blokkolásához
használd a következő parancsot:

  halt

A megállításkor egy blokktörzset is megadhatsz ...

  halt 'ez fog megjelenni a törzsben'

Vagy állítsd be mind a státuszt, mind pedig a törzset ...

  halt 401, 'menj innen!'

== Passzolás

Az útvonalak továbbadhatják a végrehajtást egy másik útvonalnak 
a <tt>pass</tt> függvényhívással:

  get '/guess/:who' do
    pass unless params[:who] == 'Frank'
    "Elkaptál!"
  end

  get '/guess/*' do
    "Elhibáztál!"
  end

Az útvonal blokkja azonnal kilép és átadja a vezérlést a következő
illeszkedő útvonalnak. Ha nem talál megfelelő útvonalat, a Sinatra
egy 404-es hibával tér vissza.

== Beállítások

Csak indításkor, de minden környezetre érvényesen fusson le:

  configure do
    ...
  end

Csak akkor fusson le, ha a környezet (a RACK_ENV környezeti változóban)
<tt>:production</tt>-ra van állítva:

  configure :production do
    ...
  end

Csak akkor fusson le, ha a környezet <tt>:production</tt> vagy <tt>:test</tt>:

  configure :production, :test do
    ...
  end

== Hibakezelés

A hibakezelők ugyanabban a kontextusban futnak le, mint az útvonalak és
előszűrők, így ugyanazok a könyvtárak elérhetőek számukra is, mint
például a <tt>haml</tt>, az <tt>erb</tt>, a <tt>halt</tt> stb.

=== Not Found

When a <tt>Sinatra::NotFound</tt> exception is raised, or the response's status
code is 404, the <tt>not_found</tt> handler is invoked:

  not_found do
    'This is nowhere to be found'
  end

=== Error

The +error+ handler is invoked any time an exception is raised from a route
block or before filter. The exception object can be obtained from the
<tt>sinatra.error</tt> Rack variable:

  error do
    'Sorry there was a nasty error - ' + env['sinatra.error'].name
  end

Custom errors:

  error MyCustomError do
    'So what happened was...' + request.env['sinatra.error'].message
  end

Then, if this happens:

  get '/' do
    raise MyCustomError, 'something bad'
  end

You get this:

  So what happened was... something bad

Sinatra installs special <tt>not_found</tt> and <tt>error</tt> handlers when
running under the development environment.

== Mime types

When using <tt>send_file</tt> or static files you may have mime types Sinatra
doesn't understand. Use +mime+ to register them by file extension:

  mime :foo, 'text/foo'

== Rack Middleware

Sinatra rides on Rack[http://rack.rubyforge.org/], a minimal standard
interface for Ruby web frameworks. One of Rack's most interesting capabilities
for application developers is support for "middleware" -- components that sit
between the server and your application monitoring and/or manipulating the
HTTP request/response to provide various types of common functionality.

Sinatra makes building Rack middleware pipelines a cinch via a top-level
+use+ method:

  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/hello' do
    'Hello World'
  end

The semantics of +use+ are identical to those defined for the
Rack::Builder[http://rack.rubyforge.org/doc/classes/Rack/Builder.html] DSL
(most frequently used from rackup files). For example, the +use+ method
accepts multiple/variable args as well as blocks:

  use Rack::Auth::Basic do |username, password|
    username == 'admin' && password == 'secret'
  end

Rack is distributed with a variety of standard middleware for logging,
debugging, URL routing, authentication, and session handling. Sinatra uses
many of of these components automatically based on configuration so you
typically don't have to +use+ them explicitly.

== Testing

Sinatra tests can be written using any Rack-based testing library
or framework. {Rack::Test}[http://gitrdoc.com/brynary/rack-test] is
recommended:

  require 'my_sinatra_app'
  require 'rack/test'

  class MyAppTest < Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Hello World!', last_response.body
    end

    def test_with_params
      get '/meet', :name => 'Frank'
      assert_equal 'Hello Frank!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
      assert_equal "You're using Songbird!", last_response.body
    end
  end

NOTE: The built-in Sinatra::Test module and Sinatra::TestHarness class
are deprecated as of the 0.9.2 release.

== Sinatra::Base - Middleware, Libraries, and Modular Apps

Defining your app at the top-level works well for micro-apps but has
considerable drawbacks when building reuseable components such as Rack
middleware, Rails metal, simple libraries with a server component, or
even Sinatra extensions. The top-level DSL pollutes the Object namespace
and assumes a micro-app style configuration (e.g., a single application
file, ./public and ./views directories, logging, exception detail page,
etc.). That's where Sinatra::Base comes into play:

  require 'sinatra/base'

  class MyApp < Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Hello world!'
    end
  end

The MyApp class is an independent Rack component that can act as
Rack middleware, a Rack application, or Rails metal. You can +use+ or
+run+ this class from a rackup +config.ru+ file; or, control a server
component shipped as a library:

   MyApp.run! :host => 'localhost', :port => 9090

The methods available to Sinatra::Base subclasses are exactly as those
available via the top-level DSL. Most top-level apps can be converted to
Sinatra::Base components with two modifications:

* Your file should require +sinatra/base+  instead of +sinatra+;
  otherwise, all of Sinatra's DSL methods are imported into the main
  namespace.
* Put your app's routes, error handlers, filters, and options in a subclass
  of Sinatra::Base.

+Sinatra::Base+ is a blank slate. Most options are disabled by default,
including the built-in server. See {Options and Configuration}[http://sinatra.github.com/configuration.html]
for details on available options and their behavior.

SIDEBAR: Sinatra's top-level DSL is implemented using a simple delegation
system. The +Sinatra::Application+ class -- a special subclass of
Sinatra::Base -- receives all :get, :put, :post, :delete, :before,
:error, :not_found, :configure, and :set messages sent to the
top-level. Have a look at the code for yourself: here's the
{Sinatra::Delegator mixin}[http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064]
being {included into the main namespace}[http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb#L25].

== Command line

Sinatra applications can be run directly:

  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-s HANDLER]

Options are:

  -h # help
  -p # set the port (default is 4567)
  -e # set the environment (default is development)
  -s # specify rack server/handler (default is thin)
  -x # turn on the mutex lock (default is off)

== The Bleeding Edge

If you would like to use Sinatra's latest bleeding code, create a local
clone and run your app with the <tt>sinatra/lib</tt> directory on the
<tt>LOAD_PATH</tt>:

  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb

Alternatively, you can add the <tt>sinatra/lib</tt> directory to the
<tt>LOAD_PATH</tt> in your application:

  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/about' do
    "I'm running version " + Sinatra::VERSION
  end

To update the Sinatra sources in the future:

  cd myproject/sinatra
  git pull

== More

* {Project Website}[http://sinatra.github.com/] - Additional documentation,
  news, and links to other resources.
* {Contributing}[http://sinatra.github.com/contributing.html] - Find a bug? Need
  help? Have a patch?
* {Lighthouse}[http://sinatra.lighthouseapp.com] - Issue tracking and release
  planning.
* {Twitter}[http://twitter.com/sinatra]
* {Mailing List}[http://groups.google.com/group/sinatrarb]
* {IRC: #sinatra}[irc://chat.freenode.net/#sinatra] on http://freenode.net
